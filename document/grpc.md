## grpc 
rpc很多人都知道，grpc就是google的标准.想应用grpc，就需要了解protobuf这个名词，官方文档给出的是解释是：一种中间语言，可以跨平台的，可扩展序列化和反序列化的一个标准协议，当然可以作为一种数据存储。
### 优点
+ 1.google的性能好，效率也高。
+ 2.代码自动生成，数据序列化和反序列化不用操心自动生成的代码帮你完成。
+ 3.兼容性好，现在已经到3了，但是grpc支持3
+ 4.适用多种语言，生态好哈。
### 如何编译这种文件
需要下载protoc执行文件编译这种文件生成代码.[有个网址可以参考](http://blog.sina.com.cn/s/blog_653ac36d0101h9kn.html)

### grpc的应用
+ 1.下载protoc可执行文件
+ 2.安装grpc-go

```js
  go get google.golang.org/grpc
```
+ 实例代码会尽快贴出来，其实很简单，GitHub上有例子。我想说的使用grpc基于http2，再加上protobuf解析数据比较快，并且比较省流量，这些特性决定了用它来提供服务化接口非常方便，不管是做saas还是paas都是非常好的选择。
+ 在做微服务架构中，我们可能会查询很多相同的信息，比如要查询用户信息。如果每个服务都去连接用户数据库，如果数据库的字段发生改变将要修改各个服务的查询接口。如果我们想优化一个查询或者进行相应的缓存方式的更改，只去修改这一层就可以了。而对外提供服务的http服务不用进行修改。

### 微服务是否进行分层
+ 如果你想让架构更加清楚，我的观点是微服务需要进行分层。服务内部的调用我们最好的方法是使用grpc同步调用或者消息队列进行异步调用。但是很多情况，我们需要对外部提供服务，在对外部提供服务的时候，一般采用http服务。那么这个http应用服务器一般是再次通过rpc的方式调用底层服务。层次清楚。

### 微服务是否需要服务发现
+ 使用了微服务，就代表你选择了轻量，小巧，可复用强，而带来的问题就是你会发现服务会很多，这么多的服务一开始就指定端口等内容将会是一个苦恼的事情。
+ 微服务一般会使用docker作为它的载体，运行在容器上，这样可以尽可能的利用服务器的资源。
+ 太多的容器，有服务发现，服务注册功能多么容易管理。
+ 怎么选择呢？etcd/Registrator/Confd这个组合还可以，Consul也可以，以前我们使用的是Consul，但是重新选择话我可能更倾向于etcd。主要当时我们对于etcd的使用认识的不够充分，zoonkeeper除非你想做数据中心，java本身来说太重了，不够轻量级，我不是故意黑某种语言，我其实挺欣赏java的。

### etcd
#### etcd能做什么
最主要作用可以作为key-value的持久化存储，但是这不仅仅有这一项功能。当使用服务发现机制的时候，需要记录服务和服务的端口等映射关系，它可以提供etcd客户端完成这个功能。但是etcd需要和其他服务或者代理一起使用才能发挥它更大的作用，现在它已经是Kubernetes组成的一部分。
#### 当前版本及优点
etcd最新的版本是etcd3 API,已经被应用到大型分布式系统，例如Kubernetes. 应用在大型的分布式协作平台，etcd3客户端使用grpc协议进行通信，协议消息使用protobuf进行定义。grpc在处理链接的时候，使用的是单一链接进行多路复用技术进行的远程调用，但是2.0的实现比较差，没有办法做复用，为每个请求建立一个链接。